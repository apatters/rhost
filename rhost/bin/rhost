#!/usr/bin/env python
"""Open a terminal logged into a remote system."""

__copyright__ = 'Copyright (C) 2016 Andrew Patterson'
__credits__ = ['Andrew Patterson']
__license__ = 'Proprietary'
__version__ = '1.1'
__maintainer__ = 'Andrew Patterson'
__email__ = 'andrew.patterson@hpe.com'

import argparse
import collections
import gtk
import inspect
import jinja2
import os
import socket
import sys
import yaml

RUNNING_DIR = os.path.dirname(os.path.abspath(sys.argv[0]))
if RUNNING_DIR == '/usr/bin':
    ICONS_DIR = os.path.join('/usr/share/rhost/icons')
else:
    ICONS_DIR = os.path.abspath(os.path.join(RUNNING_DIR, os.pardir, 'share/icons'))
    sys.path.insert(0, os.path.abspath(os.path.join(RUNNING_DIR, os.pardir, 'lib')))

import rhost.utils as utils
from rhost.trace import TRACE


options = None

PRG_NAME = utils.get_program_name()
DEFAULT_CONFIG_FILENAME = '%s/.%s.yml' % (os.environ['HOME'], PRG_NAME)


class OS_TYPE(utils.Enum):
    UNKNOWN = 0
    LINUX = 1
    WINDOWS = 2

    string_repr = {UNKNOWN: '?',
                   LINUX: 'linux',
                   WINDOWS: 'windows',}


class OrderedDictYAMLLoader(yaml.Loader):
    """
    A YAML loader that loads mappings into ordered dictionaries. Leveraged from:
    https://gist.github.com/enaeseth/844388.
    """

    def __init__(self, *args, **kwargs):
        yaml.Loader.__init__(self, *args, **kwargs)

        self.add_constructor(u'tag:yaml.org,2002:map', type(self).construct_yaml_map)
        self.add_constructor(u'tag:yaml.org,2002:omap', type(self).construct_yaml_map)

    def construct_yaml_map(self, node):
        data = collections.OrderedDict()
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_mapping(self, node, deep=False):
        if isinstance(node, yaml.MappingNode):
            self.flatten_mapping(node)
        else:
            raise yaml.constructor.ConstructorError(None, None,
                'expected a mapping node, but found %s' % node.id, node.start_mark)

        mapping = collections.OrderedDict()
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            try:
                hash(key)
            except TypeError, exc:
                raise yaml.constructor.ConstructorError('while constructing a mapping',
                    node.start_mark, 'found unacceptable key (%s)' % exc, key_node.start_mark)
            value = self.construct_object(value_node, deep=deep)
            mapping[key] = value
        return mapping


class RhostException(Exception):
    """Base exception class"""

    def __init__(self, msg=''):
        super(RhostException, self).__init__(msg)


class Config(object):
    """Holds configuration data."""

    DEFAULT_SORT_HOSTS = False
    DEFAULT_SORT_GROUPS = False
    DEFAULT_USE_GROUP_BUTTONS = False
    DEFAULT_DESCRIPTION = None
    DEFAULT_USER = None
    DEFAULT_DOMAIN = None
    DEFAULT_OS = OS_TYPE.LINUX
    DEFAULT_USE_BASTION = False
    DEFAULT_BASTION_FQDN =  None
    DEFAULT_BASTION_USER = None
    DEFAULT_GROUP = None
    DEFAULT_LINUX_TERMINAL_CMD = '/usr/bin/gnome-terminal -x ssh -X %u@%f'
    DEFAULT_LINUX_TERMINAL_WITH_BASTION_CMD = '/usr/bin/gnome-terminal -x ssh -t %U@%b ssh -X %u@%f'
    DEFAULT_WINDOWS_TERMINAL_CMD = '/usr/bin/rdesktop -T %n -u %u -d %D %f'

    def __init__(self, *pargs, **kwargs):
        """Constructor."""

        self.sort_hosts = truth_to_bool(kwargs.pop('sort_hosts', self.DEFAULT_SORT_HOSTS))
        self.sort_groups = truth_to_bool(kwargs.pop('sort_groups', self.DEFAULT_SORT_GROUPS))
        self.use_group_buttons = truth_to_bool(kwargs.pop('use_group_buttons', self.DEFAULT_USE_GROUP_BUTTONS))
        self.default_description = kwargs.pop('default_description', self.DEFAULT_DESCRIPTION)
        self.default_user = kwargs.pop('default_user', self.DEFAULT_USER)
        self.default_domain = kwargs.pop('default_domain', self.DEFAULT_DOMAIN)
        self.default_os = OS_TYPE.val(kwargs.pop('default_os', OS_TYPE.str(self.DEFAULT_OS)))
        self.default_use_bastion = truth_to_bool(kwargs.pop('default_use_bastion', self.DEFAULT_USE_BASTION))
        self.default_bastion_fqdn = kwargs.pop('default_bastion_fqdn', self.DEFAULT_BASTION_FQDN)
        self.default_bastion_user = kwargs.pop('default_bastion_user', self.DEFAULT_BASTION_USER)
        self.default_group = kwargs.pop('default_group', self.DEFAULT_GROUP)
        self.default_linux_terminal_cmd = kwargs.pop('default_linux_terminal_cmd', self.DEFAULT_LINUX_TERMINAL_CMD)
        self.default_linux_terminal_with_bastion_cmd = kwargs.pop('default_linux_terminal_with_bastion_cmd',
                                                                  self.DEFAULT_LINUX_TERMINAL_WITH_BASTION_CMD)
        self.default_windows_terminal_cmd = kwargs.pop('default_windows_terminal_cmd',
                                                       self.DEFAULT_WINDOWS_TERMINAL_CMD)

    def __str__(self):
        fmt_str = '%r:%r ' * 13
        return fmt_str % (
            'sort_hosts', self.sort_hosts,
            'sort_groups', self.sort_groups,
            'use_group_buttons', self.use_group_buttons,
            'default_description', self.default_description,
            'default_user', self.default_user,
            'default_domain', self.default_domain,
            'default_os', OS_TYPE.str(self.default_os),
            'default_use_bastion', self.default_use_bastion,
            'default_bastion_fqdn', self.default_bastion_fqdn,
            'default_bastion_user', self.default_bastion_user,
            'default_group', self.default_group,
            'default_linux_terminal_cmd', self.default_linux_terminal_cmd,
            'default_linux_terminal_with_bastion_cmd', self.default_linux_terminal_with_bastion_cmd,
            'default_windows_terminal_cmd', self.default_windows_terminal_cmd,
        )

class Host(object):
    def __init__(self, config, *pargs, **kwargs):
        """Constructor."""

        self.config = config
        self.name = kwargs.pop('name', None)
        if not self.name:
            raise RhostException("Missing 'name' in host definition,")
        self.fqdn = kwargs.pop('fqdn', None)
        if not self.fqdn:
            raise RhostException("Missing 'fqdn' in host definition,")

        self.description = kwargs.pop('description', config.default_description)
        self.user = kwargs.pop('user', config.default_user)
        self.domain = kwargs.pop('domain', config.default_domain)
        self.os = OS_TYPE.val(kwargs.pop('os', OS_TYPE.str(config.default_os)))
        self.use_bastion = kwargs.pop('use_bastion', config.default_use_bastion)
        self.bastion_fqdn = kwargs.pop('bastion_fqdn', config.default_bastion_fqdn)
        self.bastion_user = kwargs.pop('bastion_user', config.default_bastion_user)
        self.group = kwargs.pop('group', config.default_group)

        if kwargs:
            invalid_parms = ', '.join(kwargs.keys())
            raise RhostException("Unknown field(s) '%s' in host definition." % invalid_parms)
        if pargs:
            raise RhostException("Positional arguments not allowed in Host constructor.")

    def __str__(self):
        fmt_str = '%r:%r ' * 10
        return fmt_str % (
            'name', self.name,
            'fqdn', self.fqdn,
            'description', self.description,
            'user', self.user,
            'domain', self.domain,
            'os', OS_TYPE.str(self.os),
            'use_bastion', self.use_bastion,
            'bastion_fqdn', self.bastion_fqdn,
            'bastion_user', self.bastion_user,
            'group', self.group,)

    def __lt__(self, other):
        return self.name.lower() < other.name,lower()

    def substitute_fields(self, s):
        """Make host field substitutions in string s."""

        s = s.replace('%n', self.name or '')
        s = s.replace('%f', self.fqdn or '')
        s = s.replace('%d', self.description or '')
        s = s.replace('%u', self.user or '')
        s = s.replace('%D', self.domain or '')
        s = s.replace('%o', OS_TYPE.str(self.os) or '')
        s = s.replace('%b', self.bastion_fqdn or '')
        s = s.replace('%U', self.bastion_user or '')
        s = s.replace('%g', self.group or '')

        return s


class HostSelectionGui(object):

    def __init__(self, config, hosts, groups):

        self.config = config
        self.hosts = hosts
        self.groups = groups
        self.selected_host = None
        self.selected_group = None
        self.main_window = None
        self.main_window = None
        self.hosts_selection_window = None

        self.main_window = self.create_main_window()
        self.main_window.show()

    def host_callback(self, widget, host):

        self.selected_host = host
        gtk.main_quit()

        return False

    def group_callback(self, widget, group):


        self.selected_group = group
        self.hosts_selection_window = self.create_hosts_selection_window(group)
        self.hosts_selection_window.show()

        return False

    def group_cancel_callback(self, widget):

        self.hosts_selection_window.destroy()

    def create_main_window(self):

        main_window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        main_window.set_title("Remote Host")
        main_window.set_border_width(10)
        main_window.set_geometry_hints(min_width=200)

        if self.config.use_group_buttons:
            hosts_obj = self.create_hosts_in_group_frame()
        else:
             hosts_obj = self.create_hosts_by_group_vbox()

        hosts_obj.show()

        quit_button = gtk.Button(stock=gtk.STOCK_QUIT)
        quit_button.connect('clicked', lambda w: gtk.main_quit())
        quit_button.show()

        quit_box = gtk.HBox(False, 0)
        quit_box.pack_start(quit_button, True, False, 0)
        quit_box.show()

        vbox = gtk.VBox(False, 10)
        vbox.pack_start(hosts_obj, expand=False, fill=False)
        vbox.pack_end(quit_box, expand=False, fill=False)

        main_window.add(vbox)
        vbox.show()

        return main_window

    def create_hosts_selection_window(self, group):

        hosts_window = gtk.Window(type=gtk.WINDOW_POPUP)
        hosts_window.set_title(group)
        hosts_window.set_border_width(10)
        hosts_window.set_modal(True)
        hosts_window.set_transient_for(self.main_window)
        hosts_window.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DIALOG)
        hosts_window.set_destroy_with_parent(True)
        hosts_window.set_keep_above(True)
        hosts_window.set_position(gtk.WIN_POS_CENTER_ALWAYS)
        hosts_window.set_resizable(True)
        hosts_window.set_decorated(True)

        table = self.create_hosts_selection_table(self.groups[group])
        table.show()

        cancel_button = gtk.Button(stock=gtk.STOCK_CANCEL)
        cancel_button.connect('clicked', self.group_cancel_callback)
        cancel_button.show()

        cancel_box = gtk.HBox(False, 0)
        cancel_box.pack_start(cancel_button, True, False, 0)
        cancel_box.show()

        vbox = gtk.VBox(False, 10)
        vbox.pack_start(table, expand=False, fill=False)
        vbox.pack_end(cancel_box, expand=False, fill=False)
        hosts_window.add(vbox)
        vbox.show()

        return hosts_window

    def create_hosts_in_group_frame(self):

        frame = gtk.Frame('Groups')
        table = gtk.Table(rows=len(self.groups)-1, columns=1, homogeneous=False)
        idx = 0
        if self.config.sort_groups:
            group_iter = sorted(self.groups, key=str.lower).__iter__()
        else:
            group_iter = self.groups.__iter__()
        for group in group_iter:
             button = gtk.Button(group)
             button.connect('clicked', self.group_callback, group)
             button.show()
             idx += 1
             table.attach(button, 0, 1, idx, idx+1)
        frame.add(table)
        table.show()

        return frame

    def create_hosts_by_group_vbox(self):

        vbox = gtk.VBox(False, 0)
        if self.config.sort_groups:
            group_iter = sorted(self.groups).__iter__()
        else:
            group_iter = self.groups.__iter__()

        for group in group_iter:
            frame = gtk.Frame(group)
            table = self.create_hosts_selection_table(self.groups[group], self.hosts)

            frame.add(table)
            table.show()
            frame.show()
            vbox.pack_start(frame, False, True, 5)

        return vbox

    def create_hosts_selection_table(self, hosts, sort=False):

        table = gtk.Table(len(hosts) - 1, 3, False)
        table.set_col_spacing(0, 5)
        idx = 0
        for host in hosts:
            type_image = gtk.Image()
            if host.os == OS_TYPE.LINUX:
                type_image.set_from_file(os.path.join(ICONS_DIR, 'Linux-icon.png'))
            elif host.os == OS_TYPE.WINDOWS:
                type_image.set_from_file(os.path.join(ICONS_DIR, 'Windows-icon.png'))
            type_image.show()
            table.attach(type_image, 0, 1, idx, idx+1)
            button = gtk.Button(host.name)
            button.set_alignment(0, 0)
            button.connect('clicked', self.host_callback, host)
            button.show()
            table.attach(button, 1, 2, idx, idx+1, xpadding=3)
            desc_label = gtk.Label(host.description)
            desc_label.set_alignment(0, 0.5)
            desc_label.show()
            table.attach(desc_label, 2, 3, idx, idx+1, xpadding=3)
            idx += 1

        return table

    def main(self, host=None):
        gtk.main()


def truth_to_bool(word):
    """Convert an english word (Yes, yes, True, true, No, no. False, false, None, or
    empty string) to a boolean."""

    if type(word) == bool:
        return word
    if not word or word.lower() in ('no', 'false'):
        return False
    if word.lower() in ('yes', 'true'):
        return True

    raise(RhostException("Invalid truth value '%s'." % word))

def launch_host(host, config):

    if host.os == OS_TYPE.LINUX:
        if host.use_bastion:
            cmd = host.substitute_fields(config.default_linux_terminal_with_bastion_cmd)
        else:
            cmd = host.substitute_fields(config.default_linux_terminal_cmd)
    elif host.os == OS_TYPE.WINDOWS:
        cmd  = host.substitute_fields(config.default_windows_terminal_cmd)
    if options.debug:
        print(cmd)
    cmd = cmd.split()
    os.execvp(cmd[0], [os.path.basename(cmd[0])] + cmd[1:])

def parse_options():
    """Parse command-line options."""

    global options

    version = '%s %s' % (PRG_NAME, __version__)
    description = """Open a terminal logged into a remote system."""

    version_help = "Show program's version number and exit."
    config_filename_help = "Load configuration information from this file (default '%s')." % DEFAULT_CONFIG_FILENAME
    debug_help = 'Output debug information.'
    host_help = "Host to launch."
    variables_help = 'Jinja2 variable (in X=Y format). Can be specified multiple times.'

    parser = argparse.ArgumentParser(prog=PRG_NAME, description=description,
                                     add_help=True)
    parser.add_argument('--version', action='version', version=version,
                        help=version_help)
    parser.add_argument('-c', '--config', dest='config_filename',
                        default=DEFAULT_CONFIG_FILENAME, help=config_filename_help)
    parser.add_argument('-d', '--debug', dest='debug', action='store_true',
                        help=debug_help)

    parser.add_argument('host', action='store', nargs='?', default=None, help=host_help)
    parser.add_argument('-v', '--variables', action='append',
                        metavar='VARIABLE', help='variables_help')

    options = parser.parse_args()

    if not os.path.exists(options.config_filename):
        parser.error("Config file '%s' does not exist." % options.config_filename)
    options.config_filename = os.path.abspath(options.config_filename)


def load_config():

    template_vars = {}
    if options.variables:
        template_vars.update(dict(var.split('=', 1) for var in options.variables))
    # Inject running domain.
    if 'running_fqdn' not in template_vars:
        template_vars['running_fqdn'] = socket.getfqdn()
    if 'running_hostname' not in template_vars:
        template_vars['running_hostname'] = template_vars['running_fqdn'].partition('.')[0]
    if 'running_domain' not in template_vars:
        template_vars['running_domain'] = template_vars['running_fqdn'].partition('.')[2]

    loader = jinja2.FileSystemLoader('/')
    env = jinja2.Environment(loader=loader,
                             undefined=jinja2.Undefined)
    template = env.get_template(options.config_filename)
    docs = yaml.load_all(template.render(template_vars), OrderedDictYAMLLoader)

    config_doc = docs.next()
    config = Config(**config_doc)

    hosts_doc = docs.next()
    hosts = collections.OrderedDict()
    for (host_name, host_data) in hosts_doc.items():
        hosts[host_name] = Host(config, name=host_name, **host_data)

    return config, hosts

def main():

    global options
    parse_options()

    config, hosts = load_config()

    if options.host:
        if options.host not in hosts:
            print "Error: unknown host %s" % options.host
            sys.exit(1)
        launch_host(hosts[options.host], config)
    else:
        # Sets host_to_launch
        groups = collections.OrderedDict()
        for host_name, host in hosts.items():
            if host.group not in groups:
                groups[host.group] = [host]
            else:
                groups[host.group].append(host)
        gui = HostSelectionGui(config, hosts, groups)
        gui.main()
        if gui.selected_host:
            launch_host(gui.selected_host, config)

if __name__ == '__main__':

    main()
